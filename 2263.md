[BOJ 2263 트리의 순회](https://www.acmicpc.net/problem/2263)
=====
Algorithm
-----
* Divide and Conquer

Solution
-----
1. 후위 표기법 기준으로 가장 마지막에 있는 수가 전위 표기법에서는 가장 먼저 오므로 바로 출력
2. 중위 표기법 기준으로 출력된 수 이전에 있는 수들끼리 재귀
3. 이후에 있는 나머지 수들끼리 재귀

Code
-----

```cpp
#include <bits/stdc++.h>
using namespace std;

int n, idx;
vector<int> inOrder, postOrder, rootIdx;

void searchPreOrder(int, int, int, int);

int main() {
	scanf("%d", &n);
	inOrder.resize(n);
	postOrder.resize(n);
	rootIdx.resize(n + 1);
	for (int i = 0; i < n; i++)
		scanf("%d", &inOrder[i]);
	for (int i = 0; i < n; i++)
		scanf("%d", &postOrder[i]);
	for (int i = 0; i < n; i++)
		rootIdx[inOrder[i]] = i;
	searchPreOrder(0, n - 1, 0, n - 1);
}

void searchPreOrder(int inStart, int inEnd, int postStart, int postEnd) {
	int root;

	if (inStart > inEnd || postStart > postEnd)
		return;
	root = postOrder[postEnd];
	printf("%d ", root);
	searchPreOrder(inStart, rootIdx[root] - 1, postStart, postStart + rootIdx[root] - inStart - 1);
	searchPreOrder(rootIdx[root] + 1, inEnd, postStart + rootIdx[root] - inStart, postEnd - 1);
}
```

Remark
-----
* 개인적으로 순회가 종종 헷갈림.