[BOJ 10254 고속도로](https://www.acmicpc.net/problem/10254)
=====
Algorithm
-----
* Convex Hull
* Rotating Callipers

Solution
-----
1. Convex Hull을 추출
2. Rotating Callipers 방식을 이용, 벡터 back과 front를 두어 제자리로 올 때까지 최대 길이를 나타내는 두 점을 탐색

Code
-----

```cpp
#include <bits/stdc++.h>
using namespace std;

typedef long long ll;

struct pos {
	int x, y;

	pos(int _x = 0, int _y = 0) {
		this->x = _x;
		this->y = _y;
	}

	pos operator-(const pos& other) {
		return pos(other.x - this->x, other.y - this->y);
	}
};

pos coords[200000];

bool comp1(pos, pos);
ll ccw(pos, pos, pos);
ll ccw2(pos, pos, pos, pos);
bool comp2(pos, pos);
double getDist(pos, pos);

int main() {
	int T, N, hullSize, res[2];
	double maxDist, tmpDist;
	pos first, second;
	vector<pos> hull;

	scanf("%d", &T);
	while (T-- > 0) {
		scanf("%d", &N);
		for (int i = 0; i < N; i++)
			scanf("%d %d", &coords[i].x, &coords[i].y);
		sort(coords, coords + N, comp1);
		sort(coords + 1, coords + N, comp2);
		hull.clear();
		hull.push_back(first = coords[0]);
		hull.push_back(second = coords[1]);
		for (int i = 2; i < N; i++) {
			while (hull.size() >= 2) {
				second = hull.back();
				hull.pop_back();
				first = hull.back();
				if (ccw(first, second, coords[i]) > 0) {
					hull.push_back(second);
					break;
				}
			}
			hull.push_back(coords[i]);
		}
		hullSize = hull.size();
		maxDist = 0;
		for (int back = 0, front = 1; back < hullSize; back++) {
			while (back != front && ccw2(hull[back], hull[(back + 1) % hullSize], hull[front], hull[(front + 1) % hullSize]) > 0)
				front = (front + 1) % hullSize;
			if ((tmpDist = getDist(hull[back], hull[front])) > maxDist) {
				maxDist = tmpDist;
				res[0] = back;
				res[1] = front;
			}
		}
		for (int i = 0; i < 2; i++)
			printf("%d %d ", hull[res[i]].x, hull[res[i]].y);
		puts("");
	}
}

bool comp1(pos a, pos b) {
	if (a.y == b.y)
		return a.x < b.x;
	return a.y < b.y;
}

ll ccw(pos a, pos b, pos c) {
	ll x = b.x - a.x, y = b.y - a.y, z = c.x - a.x, w = c.y - a.y;

	return x * w - y * z;
}

ll ccw2(pos a, pos b, pos c, pos d) {
	return ccw(pos(), b - a, d - c);
}

bool comp2(pos a, pos b) {
	ll tmp = ccw(coords[0], a, b);

	if (tmp != 0)
		return tmp > 0;
	if (a.y == b.y)
		return a.x < b.x;
	return a.y < b.y;
}

double getDist(pos a, pos b) {
	return sqrt(pow(a.x - b.x, 2) + pow(a.y - b.y, 2));
}
```

Remark
-----
* 알고리즘이 신기했음.