[16953 BOJ A → B](https://www.acmicpc.net/problem/16953)
=====
Algorithm
-----
* DFS

Solution1
-----
1. A에서부터 시작하여, 2를 곱하거나 10을 곱해 1을 더하는 연산 두 가지로 재귀함수 호출
2. 현재의 값이 B에 도달하면 결과값과 비교하여 갱신

Solution2
-----
1. while문을 이용
2. B에서부터 시작하여 현재 값이 A보다 작거나, 10으로 나눈 나머지가 1이 아니면서 홀수이면 -1 출력
3. 10으로 나눈 나머지가 1이면 현재 값에 1을 빼고 10으로 나눔
4. 그렇지 않고 짝수이면 2로 나눔
5. 현재 값이 A에 도달하면 break 후 결과 출력

Code1
-----

```cpp
#include <bits/stdc++.h>
#define INF 1e9
using namespace std;

typedef long long ll;

int A, B, res = INF;

void f(ll, int);

int main() {
    scanf("%d %d", &A, &B);
    f(A, 1);
    printf("%d\n", res == INF ? -1 : res);
}

void f(ll cur, int cnt) {
    if (cur == B) {
        res = min(res, cnt);
        return;
    }
    if (cur * 2 <= B)
        f(cur * 2, cnt + 1);
    if (cur * 10 + 1 <= B)
        f(cur * 10 + 1, cnt + 1);
}
```

Code2
-----

```cpp
#include <bits/stdc++.h>
#define INF 1e9
using namespace std;

typedef long long ll;

int A, B, res = INF;
map<ll, int> dp;

void f(ll, int);

int main() {
    scanf("%d %d", &A, &B);
    f(A, 1);
    printf("%d\n", res == INF ? -1 : res);
}

void f(ll cur, int cnt) {
    int ret;

    if (cur == B)
        res = min(res, cnt);
    if (dp.find(cur) == dp.end()) {
        dp.insert({ cur, cnt });
        if (cur * 2 <= B && dp.find(cur * 2) == dp.end())
            f(cur * 2, cnt + 1);
        if (cur * 10 + 1 <= B && dp.find(cur * 10 + 1) == dp.end())
            f(cur * 10 + 1, cnt + 1);
    }
}
```

Code3
-----

```cpp
#include <bits/stdc++.h>
using namespace std;

int main() {
    int A, B, res = 1;

    scanf("%d %d", &A, &B);
    while (1) {
        if (A == B)
            break;
        else if (A > B || B % 10 != 1 && B % 2 == 1) {
            res = -1;
            break;
        }
        if (B % 10 == 1)
            B = (--B) / 10;
        else
            B /= 2;
        ++res;
    }
    printf("%d\n", res);
}
```

Remark
-----
* 정공법으로도 해결이 가능하지만 더 나은 방법이 있었음. 그리고 2번 코드와 같이 memoization 기법을 쓰면 시간, 메모리 모두 낭비됨. 단순 인덱싱을 이용하기 위해 숫자 하나하나에 대응하는 배열로 만들면 메모리 초과가 발생함.