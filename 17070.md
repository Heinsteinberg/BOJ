[BOJ 17070 파이프 옮기기1](https://www.acmicpc.net/problem/17070)
=====
Algorithm
-----
* DP

Solution
-----
1. dp[r][c][d]는 마지막 방향이 d인 상태로 (r, c)에 도달하는 경우의 수
2. dp[0][1][0] = 1이며, 첫 행에서는 벽이 나오기 전까지 dp[0][c][0] = 1
3. wall 배열을 첫 원소부터 마지막 원소까지 차례로 돌아가며 3가지 방향의 dp table에 값 대입
4. wall[r][c]가 1일 때에는 건너뜀

Code
-----

```cpp
#include <bits/stdc++.h>
using namespace std;

int main() {
	int N, wall[16][16], dp[16][16][3] = {};

	scanf("%d", &N);
	for (int i = 0; i < N; i++)
		for (int j = 0; j < N; j++)
			scanf("%d", &wall[i][j]);
	for (int j = 1; j < N && !wall[0][j]; j++)
		dp[0][j][0] = 1;
	for(int i = 1; i < N; i++)
		for (int j = 1; j < N; j++) {
			if (wall[i][j])
				continue;
			dp[i][j][0] = dp[i][j - 1][0] + dp[i][j - 1][1];
			if (!wall[i][j - 1] && !wall[i - 1][j])
				dp[i][j][1] = dp[i - 1][j - 1][0] + dp[i - 1][j - 1][1] + dp[i - 1][j - 1][2];
			dp[i][j][2] = dp[i - 1][j][1] + dp[i - 1][j][2];
		}
	printf("%d\n", dp[N - 1][N - 1][0] + dp[N - 1][N - 1][1] + dp[N - 1][N - 1][2]);
}
```

Remark
-----
* 뻔한 문제이지만 생각보다 구현이 안 되어 헤맸음.